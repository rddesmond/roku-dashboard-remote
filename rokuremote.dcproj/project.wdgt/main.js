/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

var rokuip = '192.168.1.101';
var keydown = false;
var currentkeydown = null;

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    dashcode.setupParts();
    
    if(window.widget)
        rokuip = widget.preferenceForKey(dashcode.createInstancePreferenceKey("rokuip"));

    if (rokuip == null)
        rokuip = '0.0.0.0';

    var rokuipinput = document.getElementById("rokuipinput");
    rokuipinput.value = rokuip;
    onIpChange();

}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    alert('remove');
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("rokuip"));
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    if (currentkeydown != null)
    {
        var button = getButtonFromCmd(currentkeydown);
        if (button != null && button.object != null && button.object._setPressed)
            button.object._setPressed(false);
        //rokusend("keyup/"+currentkeydown);
    }

    // Stop any timers to prevent CPU usage
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // Restart any timers that were stopped on hide
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");
    var rokuinput = document.getElementById("rokuipinput");

    if (window.widget)
    {
        widget.prepareForTransition("ToBack");
    }

    front.style.display = "none";
    back.style.display = "block";

    if (window.widget)
    {
        setTimeout('widget.performTransition();', 0);
    }
    rokuinput.select();
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    onIpChange(event)
    
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget)
    {
        widget.prepareForTransition("ToFront");
    }

    front.style.display="block";
    back.style.display="none";

    if (window.widget)
    {
        setTimeout('widget.performTransition();', 0);
    }
}

if (window.widget)
{
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}



/**
 *  IP MANAGEMENT
 */

// Function: verifyRoku
// Determine the viability of the given IP and set the indicator accordingly
//  BLACK  - No input or undecided
//  RED    - Not a valid IP
//  ORANGE - Valid IP, but not responding as ROKU
//  GREEN  - Valid IP responding as ROKU
var http = null;
function verifyRoku(rokuip)
{

    var alertloc = document.getElementById("rokuipalert");
    alertloc.object.setValue(0);
    
    if (rokuip == '')
    {
        // no op
    }
    else if (!isValidIp(rokuip))
    {
        alertloc.object.setValue(alertloc.object.criticalValue);
    }
    else
    {
        try
        {
            var url = "http://"+rokuip+":8060/";
            if (null != http)
                http.abort();
            http = new XMLHttpRequest();
 
            http.onreadystatechange = function()
            {
                if (http.readyState == XMLHttpRequest.DONE)
                {
                    var response = http.responseText;
                    if (response.indexOf('Roku Streaming Player') != -1)
                    {
                        alertloc.object.setValue(alertloc.object.onValue);
                    }
                    else
                    {
                        alertloc.object.setValue(alertloc.object.warningValue);
                    }
                }
            }
            http.ontimeout = function()
            {
                alertloc.object.setValue(alertloc.object.warningValue);
            }
        
            http.timeout = 5000;
            http.open("GET", url, true);
            http.send(null);

        } catch (ex) {
            alertloc.object.setValue(alertloc.object.warningValue);
        }
    }
    
    return false;
}

function isValidIp(IPvalue)
{

    errorString = "";
    theName = "IPaddress";

    var ipPattern = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    var ipArray = IPvalue.match(ipPattern);

    if (IPvalue == "0.0.0.0")
        errorString = errorString + theName + ': '+IPvalue+' is a special IP address and cannot be used here.';
    else if (IPvalue == "255.255.255.255")
        errorString = errorString + theName + ': '+IPvalue+' is a special IP address and cannot be used here.';
    if (ipArray == null)
        errorString = errorString + theName + ': '+IPvalue+' is not a valid IP address.';
    else {
        for (i = 0; i < 4; i++) {
            thisSegment = ipArray[i];
            if (thisSegment > 255) {
                errorString = errorString + theName + ': '+IPvalue+' is not a valid IP address.';
                i = 4;
            }
            if ((i == 0) && (thisSegment > 255)) {
                errorString = errorString + theName + ': '+IPvalue+' is a special IP address and cannot be used here.';
                i = 4;
            }
        }
    }
    extensionLength = 3;
    if (errorString == "")
        return true;
    else
        return false;
        
}


// Function: onIpChange(command)
//
function onIpChange(event)
{
    var ip = document.getElementById("rokuipinput").value;
    
    verifyRoku(ip);
    rokuip = ip;
    
    if(window.widget)
    {
        widget.setPreferenceForKey(ip, dashcode.createInstancePreferenceKey("rokuip"));
    }

    return true

}




/**
 *  ACTION FUNCTIONS
 */

// Function: rokusend(command)
// Send a synchronous post command to the current ROKU
//
function rokusend(command)
{
    try
    {
        var http = new XMLHttpRequest();
        var url = "http://"+rokuip+":8060/"+command;
        http.open("POST", url, true);
        http.send(null);
        http.timeout = 500;
        alert('sent '+command);
    }
    catch(ex)
    {
        alert('failed '+command+': '+ ex);
    }
}


//
// Function: signalSend(command)
// Generate a signal to the user when a command is sent,
// particularly useful for keyboard commands, since there is no 
// matching button event
//
function signalSend(command)
{

}


//
// Function: toggleKeyboard(event)
// Toggle the state of the keyboard lock internally and with the GUI
//
var keyboardLock = false;
function toggleKeyboard(event)
{
    var keyboardButton = document.getElementById('keyboardbutton');
    if (keyboardLock == true)
    {
        keyboardLock = false;
        keyboardButton.object._setPressed(false);
    }
    else
    {
        keyboardLock = true;
        keyboardButton.object._setPressed(true);
    }
    
    if (event && event.stopPropagation && event.preventDefault)
    {
        event.stopPropagation();
        event.preventDefault();
    }
}




/**
 *  EVENT HANDLERS
 */

//
// Function: keypresshandler(event)
// Called a key is pressed and released.  If the front is shown and the key
// represents a command.  The commands sent here have been determined to not need
// repetition, a keypress is sent to the ROKU.
//
// event: a global onKeypress event
//
function keypresshandler(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (event.keyIdentifier == 'U+0060') // Backtick
    {
        toggleKeyboard();
        return;
    }

    alert("keypress " + event.keyIdentifier);
    if (back.style.display != "none" && event.keyIdentifier == "Enter")
        showFront(event)

    var command = parseKeyPress(event);
    if (command != null && front.style.display != "none" && keyboardLock)
        rokusend("keypress/"+command);

	
    var command = parseKeyCommand(event)
    if (command != null && front.style.display != "none")
        rokusend("keypress/"+command);


}


//
// Function: keydownhandler(event)
// Called when a key is pressed down.  If the front is shown and the key
// represents a special command, a keydown is sent to the ROKU.
//
// event: a global onKeydown event
//
function keydownhandler(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (event.keyIdentifier == 'U+0060') // Backtick
        return;

    var command = parseKeyCommand()
    if (command != null && !keydown)
    {
        keydown = true;

        var button = getButtonFromCmd(command);

        if (front.style.display != "none")
        {
            if (button != null && button.object != null && button.object._setPressed)
                button.object._setPressed(true);
            //rokusend("keydown/"+command);
            currentkeydown = command;
        }
    }
    
}


//
// Function: keyuphandler(event)
// Called a key is released.  If the front is shown and the key
// represents a special command, a keyup is sent to the ROKU.
//
// event: a global onKeyup event
//
function keyuphandler(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (event.keyIdentifier == 'U+0060') // Backtick
        return;

    if (front.style.display == "none")
    {
        onIpChange(event);
	return;
    }

    var command = parseKeyCommand(event);
    if (command != null)
    {
        var button = getButtonFromCmd(command);
        if (front.style.display != "none")
        {
            if (button != null && button.object != null && button.object._setPressed)
                button.object._setPressed(false);
            //rokusend("keyup/"+command);
            currentkeydown = null;
        }
    }

    keydown = false;
}



/**
 *  COMMAND PARSING
 */

//
// Function: buttonselect(event)
// Called when a command button is pressed to send a keypress command to the
// ROKU box.  Note that a NETFLIX bug requires arrow keys to be sent as a
// keydown/keyup.
//
// event: a onClick event on a button
//
function buttonselect(event)
{
    var id = this.element.id;
    if (id == 'null')
        return
        
    else if (id == 'rightbutton')
    {
        rokusend('keypress/Right');	
        //rokusend('keydown/Right');
        //rokusend('keyup/Right');
    }
    else if (id == 'leftbutton')
    {
        rokusend('keypress/Left');	
        //rokusend('keydown/Left');
        //rokusend('keyup/Left');
    }
    else if (id == 'upbutton')
    {
        rokusend('keypress/Up');	
        //rokusend('keydown/Up');
        //rokusend('keyup/Up');
    }
    else if (id == 'downbutton')
    {
        rokusend('keypress/Down');	
        //rokusend('keydown/Down');
        //rokusend('keyup/Down');
    }
    
    else if (id == 'enterbutton')
        rokusend('keypress/Enter');
    else if (id == 'selectbutton')
        rokusend('keypress/Select');
    else if (id == 'fwdbutton')
        rokusend('keypress/Fwd');
    else if (id == 'playbutton')
        rokusend('keypress/Play');
    else if (id == 'rwdbutton')
        rokusend('keypress/Rev');
    else if (id == 'homebutton')
        rokusend('keypress/Home');
        
    else if (id == 'backbutton')
        rokusend('keypress/Back');
    else if (id == 'infobutton')
        rokusend('keypress/Info');
    else if (id == 'searchbutton')
        rokusend('keypress/Search');
}


//
// Function: parseKeyPress(event)
// Parse a keypress (for the keys to send as a press instead of up/down),
// implementationally, this generates a command during a KEYBOARDLOCK.
//
function parseKeyPress(event)
{
    if (keyboardLock && event.which >= 32 && event.which <= 126) // ASCII Printable Characters
        return 'Lit_'+escape(String.fromCharCode(event.which));
        
    return null;
}


//
// Function: getButtonFromCmd(cmd)
// Obtain a reference to a DOM button given a command
//
function getButtonFromCmd(cmd)
{
    if (cmd == null)
        return null;
        
    else if (cmd == 'Up')
        return document.getElementById('upbutton');
    else if (cmd == 'Down')
        return document.getElementById('downbutton');
    else if (cmd == 'Left')
        return document.getElementById('leftbutton');
    else if (cmd == 'Right')
        return document.getElementById('rightbutton');
        
    else if (cmd == 'Select')
        return document.getElementById('selectbutton');
    else if (cmd == 'Fwd')
        return document.getElementById('fwdbutton');
    else if (cmd == 'Play')
        return document.getElementById('playbutton');
    else if (cmd == 'Rev')
        return document.getElementById('rwdbutton');
    else if (cmd == 'Home')
        return document.getElementById('homebutton');
        
    else if (cmd == 'Back')
        return document.getElementById('backbutton');
    else if (cmd == 'Info')
        return document.getElementById('infobutton');
    else if (cmd == 'Search')
        return document.getElementById('searchbutton');
        
    return null;
}


//
// Function: parseKeyCommand(event)
// Obtain a command from a key{up/down/press} event
//
function parseKeyCommand(event)
{
    var command = null;

    var key = event.keyIdentifier;
    
    if (key == 'null')
        return null;
    else if (key == 'Up')
        command = 'Up';
    else if (key == 'Down')
        command = 'Down';
    else if (key == 'Left')
        command = 'Left';
    else if (key == 'Right')
        command = 'Right';
    else if (key == 'Enter' && keyboardLock)
        command = 'Enter';
    else if (key == 'Enter' && !keyboardLock)
        command = 'Select';
    else if (key == 'U+0008') // Delete
        command = 'Backspace';
        
        
    else if (!keyboardLock && key == 'U+0020') // Space
        command = 'Play';
    else if (!keyboardLock && key == 'U+0048') // H
        command = 'Home';
    else if (!keyboardLock && (key == 'U+002C' || key == 'U+003C')) // <
        command = 'Rev';
    else if (!keyboardLock && (key == 'U+002E' || key == 'U+003E')) // >
        command = 'Fwd';
        
    else if (!keyboardLock && key == 'U+0042') // B
        command = 'Back';
    else if (!keyboardLock && key == 'U+0049') // I
        command = 'Info';
    else if (!keyboardLock && key == 'U+0053') // S
        command = 'Search';


    return command;
}
